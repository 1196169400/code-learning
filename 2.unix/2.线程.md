# 线程

#### 一.线程标识

```c++
#include <pthread.h>
pthread_t pthread_self(void);
//返回值：调用线程的线程ID
```

#### 二.线程创建

```c++
#include <pthread.h>
int pthread_create(pthread_t *restrict tidp,
                  const pthread_attr_t *restrict attr,
                  void * (*start_rtn)(void *), void *restrict arg);
//返回值：若成功，返回0；否则，返回错误编号
```

例如

```c++
#include "apue.h"
#include <phread.h>

pthread_t ntid;

void printids(const char *s)
{
    pid_t pid;
    pthread_t tid;
    
    pid = getpid();
    //这里不直接用ntid的原因是，该函数完全有可能在线程创建函数返回之前就已经执行
    tid = pthread_self();
    printf("%s pid %lu tid %lu (0x%lx)\n", s, (unsigned long)pid,
          (unsigned long)tid, (unsigned long)tid);
}

void* thr_fn(void *arg)
{
    printids("new thread: ");
    return ((void*)0);
}

int main(void)
{
    int err;
    
    err = pthread_create(&ntid, NULL, thr_fn, NULL);
    if (err != 0)
        err_exit(err, "can't create thread");
    printids("main thread:");
    sleep(1);//休眠的原因是，有可能新线程还没来得及执行，主线程就已经退出；
    exit(0);
}
```

#### 三.线程终止

线程退出的三种方式：

1. 线程可以简单的从启动例程中返回，返回值是线程的退出码；
2. 线程可以被同一进程中的其他线程取消；
3. 线程调用pthread_exit；

```c++
#include <pthread.h>
void pthread_exit(void *rval_ptr);

#include <pthread.h>
int pthread_join(pthread_t thread, void **rval_ptr);
//返回值：若成功，返回0；否则，返回错误编号

#include <pthread.h>
int pthread_detach(pthread_t tid);
//返回值：若成功，返回0；否则，返回错误编号
```

例如：

```c++
#include "apue.h"
#include <pthread.h>

struct foo {
    int a, b, c, d;
};

void printfoo(const char *s, const struct foo *fp)
{
    printf("%s", s);
    printf(" structure at 0x%lx\n", (unsigned long)fp);
    printf(" foo.a = %d\n", fp->a);
    printf(" foo.b = %d\n", fp->b);
    printf(" foo.c = %d\n", fp->c);
    printf(" foo.d = %d\n", fp->d);
}

void* thr_fn1(void *arg)
{
    struct foo foo = {1, 2, 3, 4};
    
    printfoo("thread 1:\n", &foo);
    //foo为局部变量，该函数返回后，再在主线程查看该位置的值，其值已经改变(未知)
    pthread_exit((void*)&foo);
}

void* thr_fn2(void *arg)
{
    printf("thread 2: ID is %lu\n", (unsigned long)pthread_self());
    pthread_exit((void*)0);
}

int main()
{
    int err;
    pthread_t tid1, tid2;
    struct foo *fp;
    
    err = pthread_create(&tid1, NULL, thr_fn1, NULL);
    if (err != 0)
        err_exit(err, "can't create thread 1");
    err = pthread_join(tid1, (void*)&fp);
    if (err != 0)
        err_exit(err, "can't join with thread 1");
    sleep(1);
    printf("parent starting second thread\n");
    err = pthrad_create(&tid2, NULL, thr_fn2, NULL);
    if (err != 0)
        err_exit(err, "can't create thread 2");
    sleep(1);
    printfoo("parent:\n", fp);
    exit(0);
}
```

